load("@rules_foreign_cc//foreign_cc:defs.bzl", "configure_make")

filegroup(
    name="all_srcs",
    srcs=glob(["**"]),
)

configure_make(
    name="xmlsec1",
    lib_name="xmlsec1",
    lib_source=":all_srcs",
    # This is a nasty workaround for Bazel's inability to escape `$ORIGIN`
    # combined with foreign_cc/configure_make's RPATH agnosticness
    #   see https://github.com/bazelbuild/rules_foreign_cc/issues/940
    env={"ORIGIN_VAR": "\\\\$$\\$$ORIGIN"},
    # don't set RPATH via `opts`, the compiler path will be added, too then
    #copts=["-Wl,--rpath,$ORIGIN_VAR/../lib"],
    
    configure_command="configure",
    configure_in_place=True,
    configure_options = [
        "--with-openssl=$EXT_BUILD_DEPS/openssl",
        "--disable-mans",
        "--disable-docs",
        # set RPATH
        # There is a caveat left, though: this rule will append the actual build
        # directory resulting in build artifacts which are not binary identical
        # even when built in an exact same environment
        # This can be worked around by setting RPATH again after `bazel build` still
        # leaving us with RPATH placeholders of different size
        # Unfortunately this does not work for dynamic libraries, since strangely
        # for those the flags definded with `copts` will be appended rather than
        # prepended, resulting in wrong RPATH components in front of `$ORIGIN/../lib`
        # For that reason we need to manually set RPATH outside Bazel (during `make`)
        "LDFLAGS='-Wl,-rpath,${ORIGIN_VAR}/../lib'",
    ],
    args=["-j6"],
    deps=["@openssl"],
    out_binaries=["xmlsec1"],
    # Looks like Bazel doesn't know .la files, but we need them.
    #  see https://stackoverflow.com/questions/75282435
    # So instead of listing library files explicitly we just deliver the
    # whole `lib` folder, containing shared and dynamic libraries as well as
    # .la files
    out_data_dirs=["lib"],
    targets=["install"],
)
